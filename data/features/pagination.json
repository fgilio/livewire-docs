{
    "slug": "pagination",
    "title": "Pagination",
    "description": "Laravel's pagination feature allows you to query a subset of data and provides your users with the ability to navigate between pages of those results.",
    "category": "features",
    "url": "https://livewire.laravel.com/docs/3.x/pagination",
    "sections": [
        {
            "title": "#Basic usage",
            "content": "Below is the most basic example of using pagination inside a ShowPosts component to only show ten posts at a time:\nTo take advantage of Livewire's pagination features, each component containing pagination must use the Livewire\\WithPagination trait.\nAs you can see, in addition to limiting the number of posts shown via the Post::paginate() method, we will also use $posts->links() to render page navigation links.\nFor more information on pagination using Laravel, check out Laravel's comprehensive pagination documentation.",
            "examples": [
                {
                    "code": "<?php namespace App\\Livewire; use Livewire\\WithPagination;use Livewire\\Component;use App\\Models\\Post; class ShowPosts extends Component{ use WithPagination;  public function render() { return view('show-posts', [ 'posts' => Post::paginate(10), ]); }}",
                    "type": "class"
                },
                {
                    "code": "<div> <div> @foreach ($posts as $post) <!-- ... --> @endforeach </div>  {{ $posts->links() }}</div>",
                    "type": "class"
                }
            ]
        },
        {
            "title": "#Disabling URL query string tracking",
            "content": "By default, Livewire's paginator tracks the current page in the browser URL's query string like so: ?page=2.\nIf you wish to still use Livewire's pagination utility, but disable query string tracking, you can do so using the WithoutUrlPagination trait:\nNow, pagination will work as expected, but the current page won't show up in the query string. This also means the current page won't be persisted across page changes.",
            "examples": [
                {
                    "code": "use Livewire\\WithoutUrlPagination;use Livewire\\WithPagination;use Livewire\\Component; class ShowPosts extends Component{ use WithPagination, WithoutUrlPagination;   // ...}",
                    "type": "class"
                }
            ]
        },
        {
            "title": "#Customizing scroll behavior",
            "content": "By default, Livewire's paginator scrolls to the top of the page after every page change.\nYou can disable this behavior by passing false to the scrollTo parameter of the links() method like so:\nAlternatively, you can provide any CSS selector to the scrollTo parameter, and Livewire will find the nearest element matching that selector and scroll to it after each navigation:",
            "examples": [
                {
                    "code": "{{ $posts->links(data: ['scrollTo' => false]) }}",
                    "type": "class"
                },
                {
                    "code": "{{ $posts->links(data: ['scrollTo' => '#paginated-posts']) }}",
                    "type": "class"
                }
            ]
        },
        {
            "title": "#Resetting the page",
            "content": "When sorting or filtering results, it is common to want to reset the page number back to 1.\nFor this reason, Livewire provides the $this->resetPage() method, allowing you to reset the page number from anywhere in your component.\nThe following component demonstrates using this method to reset the page after the search form is submitted:\nNow, if a user was on page 5 of the results and then filtered the results further by pressing \"Search posts\", the page would be reset back to 1.\nIn addition to $this->resetPage(), Livewire provides other useful methods for navigating between pages programmatically from your component:",
            "examples": [
                {
                    "code": "<?php namespace App\\Livewire; use Livewire\\WithPagination;use Livewire\\Component;use App\\Models\\Post; class SearchPosts extends Component{ use WithPagination;  public $query = '';  public function search() { $this->resetPage(); }  public function render() { return view('show-posts', [ 'posts' => Post::where('title', 'like', '%'.$this->query.'%')->paginate(10), ]); }}",
                    "type": "class"
                },
                {
                    "code": "<div> <form wire:submit=\"search\"> <input type=\"text\" wire:model=\"query\">  <button type=\"submit\">Search posts</button> </form>  <div> @foreach ($posts as $post) <!-- ... --> @endforeach </div>  {{ $posts->links() }}</div>",
                    "type": "class"
                }
            ]
        },
        {
            "title": "#Multiple paginators",
            "content": "Because both Laravel and Livewire use URL query string parameters to store and track the current page number, if a single page contains multiple paginators, it's important to assign them different names.\nTo demonstrate the problem more clearly, consider the following ShowClients component:\nAs you can see, the above component contains a paginated set of clients. If a user were to navigate to page 2 of this result set, the URL might look like the following:\nSuppose the page also contains a ShowInvoices component that also uses pagination. To independently track each paginator's current page, you need to specify a name for the second paginator like so:\nNow, because of the pageName parameter that has been added to the paginate method, when a user visits page 2 of the invoices, the URL will contain the following:\nWhen using Livewire's page navigation methods on a named paginator, you must provide the page name as an additional parameter:",
            "examples": [
                {
                    "code": "use Livewire\\WithPagination;use Livewire\\Component;use App\\Models\\Client; class ShowClients extends Component{ use WithPagination;  public function render() { return view('show-clients', [ 'clients' => Client::paginate(10), ]); }}",
                    "type": "class"
                },
                {
                    "code": "http://application.test/?page=2",
                    "type": "class"
                },
                {
                    "code": "use Livewire\\WithPagination;use Livewire\\Component;use App\\Models\\Invoices; class ShowInvoices extends Component{ use WithPagination;  public function render() { return view('show-invoices', [ 'invoices' => Invoice::paginate(10, pageName: 'invoices-page'), ]); }}",
                    "type": "class"
                },
                {
                    "code": "https://application.test/customers?page=2&invoices-page=2",
                    "type": "class"
                },
                {
                    "code": "$this->setPage(2, pageName: 'invoices-page'); $this->resetPage(pageName: 'invoices-page'); $this->nextPage(pageName: 'invoices-page'); $this->previousPage(pageName: 'invoices-page');",
                    "type": "class"
                }
            ]
        },
        {
            "title": "#Hooking into page updates",
            "content": "Livewire allows you to execute code before and after a page is updated by defining either of the following methods inside your component:\nThe previous hooks only apply to the default paginator. If you are using a named paginator, you must define the methods using the paginator's name.\nFor example, below is an example of what a hook for a paginator named invoices-page would look like:\nIf you prefer to not reference the paginator name in the hook method name, you can use the more generic alternatives and simply receive the $pageName as a second argument to the hook method:",
            "examples": [
                {
                    "code": "use Livewire\\WithPagination; class ShowPosts extends Component{ use WithPagination;  public function updatingPage($page) { // Runs before the page is updated for this component... }  public function updatedPage($page) { // Runs after the page is updated for this component... }  public function render() { return view('show-posts', [ 'posts' => Post::paginate(10), ]); }}",
                    "type": "class"
                },
                {
                    "code": "public function updatingInvoicesPage($page){ //}",
                    "type": "class"
                },
                {
                    "code": "public function updatingPaginators($page, $pageName){ // Runs before the page is updated for this component...} public function updatedPaginators($page, $pageName){ // Runs after the page is updated for this component...}",
                    "type": "class"
                }
            ]
        },
        {
            "title": "#Using the simple theme",
            "content": "You can use Laravel's simplePaginate() method instead of paginate() for added speed and simplicity.\nWhen paginating results using this method, only next and previous navigation links will be shown to the user instead of individual links for each page number:\nFor more information on simple pagination, check out Laravel's \"simplePaginator\" documentation.",
            "examples": [
                {
                    "code": "public function render(){ return view('show-posts', [ 'posts' => Post::simplePaginate(10), ]);}",
                    "type": "class"
                }
            ]
        },
        {
            "title": "#Using cursor pagination",
            "content": "Livewire also supports using Laravel's cursor pagination — a faster pagination method useful in large datasets:\nBy using cursorPaginate() instead of paginate() or simplePaginate(), the query string in your application's URL will store an encoded cursor instead of a standard page number. For example:\nFor more information on cursor pagination, check out Laravel's cursor pagination documentation.",
            "examples": [
                {
                    "code": "public function render(){ return view('show-posts', [ 'posts' => Post::cursorPaginate(10), ]);}",
                    "type": "class"
                },
                {
                    "code": "https://example.com/posts?cursor=eyJpZCI6MTUsIl9wb2ludHNUb05leHRJdGVtcyI6dHJ1ZX0",
                    "type": "class"
                }
            ]
        },
        {
            "title": "#Using Bootstrap instead of Tailwind",
            "content": "If you are using Bootstrap instead of Tailwind as your application's CSS framework, you can configure Livewire to use Bootstrap styled pagination views instead of the default Tailwind views.\nTo accomplish this, set the pagination_theme configuration value in your application's config/livewire.php file:\nBefore customizing the pagination theme, you must first publish Livewire's configuration file to your application's /config directory by running the following command:",
            "examples": [
                {
                    "code": "'pagination_theme' => 'bootstrap',",
                    "type": "class"
                },
                {
                    "code": "php artisan livewire:publish --config",
                    "type": "class"
                }
            ]
        },
        {
            "title": "#Modifying the default pagination views",
            "content": "If you want to modify Livewire's pagination views to fit your application's style, you can do so by publishing them using the following command:\nAfter running this command, the following four files will be inserted into the resources/views/vendor/livewire directory:\nOnce the files have been published, you have complete control over them. When rendering pagination links using the paginated result's ->links() method inside your template, Livewire will use these files instead of its own.",
            "examples": [
                {
                    "code": "php artisan livewire:publish --pagination",
                    "type": "class"
                }
            ]
        },
        {
            "title": "#Using custom pagination views",
            "content": "If you wish to bypass Livewire's pagination views entirely, you can render your own in one of two ways:\nThe first approach is to simply pass your custom pagination Blade view name to the ->links() method directly:\nWhen rendering the pagination links, Livewire will now look for a view at resources/views/custom-pagination-links.blade.php.\nThe second approach is to declare a paginationView or paginationSimpleView method inside your component which returns the name of the view you would like to use:\nBelow is an unstyled sample of a simple Livewire pagination view for your reference.\nAs you can see, you can use Livewire's page navigation helpers like $this->nextPage() directly inside your template by adding wire:click=\"nextPage\" to buttons:",
            "examples": [
                {
                    "code": "{{ $posts->links('custom-pagination-links') }}",
                    "type": "class"
                },
                {
                    "code": "public function paginationView(){ return 'custom-pagination-links-view';} public function paginationSimpleView(){ return 'custom-simple-pagination-links-view';}",
                    "type": "class"
                },
                {
                    "code": "<div> @if ($paginator->hasPages()) <nav role=\"navigation\" aria-label=\"Pagination Navigation\"> <span> @if ($paginator->onFirstPage()) <span>Previous</span> @else <button wire:click=\"previousPage\" wire:loading.attr=\"disabled\" rel=\"prev\">Previous</button> @endif </span>  <span> @if ($paginator->onLastPage()) <span>Next</span> @else <button wire:click=\"nextPage\" wire:loading.attr=\"disabled\" rel=\"next\">Next</button> @endif </span> </nav> @endif</div>",
                    "type": "class"
                }
            ]
        }
    ],
    "directives_used": [
        "wire:click",
        "wire:loading",
        "wire:model",
        "wire:publish",
        "wire:submit"
    ],
    "related": [
        "quickstart",
        "installation",
        "upgrading",
        "components",
        "properties",
        "actions",
        "forms",
        "events",
        "lifecycle-hooks",
        "nesting"
    ],
    "scraped_at": "2026-01-02T23:37:18+00:00"
}
