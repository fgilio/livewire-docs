{
    "slug": "wire-dirty",
    "title": "wire:dirty",
    "description": "In a traditional HTML page containing a form, the form is only ever submitted when the user presses the \"Submit\" button.",
    "category": "features",
    "url": "https://livewire.laravel.com/docs/3.x/wire-dirty",
    "sections": [
        {
            "title": "#Basic usage",
            "content": "Livewire allows you to easily toggle visual elements on the page using the wire:dirty directive.\nBy adding wire:dirty to an element, you are instructing Livewire to only show the element when the client-side state diverges from the server-side state.\nTo demonstrate, here is an example of an UpdatePost form containing a visual \"Unsaved changes...\" indication that signals to the user that the form contains input that has not been saved:\nBecause wire:dirty has been added to the \"Unsaved changes...\" message, the message will be hidden by default. Livewire will automatically display the message when the user starts modifying the form inputs.\nWhen the user submits the form, the message will disappear again, since the server / client data is back in sync.\nBy adding the .remove modifier to wire:dirty, you can instead show an element by default and only hide it when the component has \"dirty\" state:",
            "examples": [
                {
                    "code": "<form wire:submit=\"update\"> <input type=\"text\" wire:model=\"title\">  <!-- ... -->  <button type=\"submit\">Update</button>  <div wire:dirty>Unsaved changes...</div> </form>",
                    "type": "class"
                },
                {
                    "code": "<div wire:dirty.remove>The data is in-sync...</div>",
                    "type": "class"
                }
            ]
        },
        {
            "title": "#Targeting property updates",
            "content": "Imagine you are using wire:model.blur to update a property on the server immediately after a user leaves an input field. In this scenario, you can provide a \"dirty\" indication for only that property by adding wire:target to the element that contains the wire:dirty directive.\nHere is an example of only showing a dirty indication when the title property has been changed:",
            "examples": [
                {
                    "code": "<form wire:submit=\"update\"> <input wire:model.blur=\"title\">  <div wire:dirty wire:target=\"title\">Unsaved title...</div>   <button type=\"submit\">Update</button></form>",
                    "type": "class"
                }
            ]
        },
        {
            "title": "#Toggling classes",
            "content": "Often, instead of toggling entire elements, you may want to toggle individual CSS classes on an input when its state is \"dirty\".\nBelow is an example where a user types into an input field and the border becomes yellow, indicating an \"unsaved\" state. Then, when the user tabs away from the field, the border is removed, indicating that the state has been saved on the server:",
            "examples": [
                {
                    "code": "<input wire:model.blur=\"title\" wire:dirty.class=\"border-yellow-500\">",
                    "type": "class"
                }
            ]
        }
    ],
    "directives_used": [
        "wire:dirty",
        "wire:model",
        "wire:submit",
        "wire:target"
    ],
    "related": [
        "quickstart",
        "installation",
        "upgrading",
        "components",
        "properties",
        "actions",
        "forms",
        "events",
        "lifecycle-hooks",
        "nesting"
    ],
    "scraped_at": "2026-01-02T23:37:41+00:00"
}
