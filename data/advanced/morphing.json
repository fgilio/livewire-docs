{
    "slug": "morphing",
    "title": "Morphing",
    "description": "When a Livewire component updates the browser's DOM, it does so in an intelligent way we call \"morphing\". The term morph is in contrast with a word like replace.",
    "category": "advanced",
    "url": "https://livewire.laravel.com/docs/3.x/morphing",
    "sections": [
        {
            "title": "#How morphing works",
            "content": "To understand how Livewire determines which elements to update between Livewire requests, consider this simple Todos component:\nThe initial render of this component will output the following HTML:\nNow, imagine you typed \"third\" into the input field and pressed the [Enter] key. The newly rendered HTML would be:\nWhen Livewire processes the component update, it morphs the original DOM into the newly rendered HTML. The following visualization should intuitively give you an understanding of how it works:\nAs you can see, Livewire walks both HTML trees simultaneously. As it encounters each element in both trees, it compares them for changes, additions, and removals. If it detects one, it surgically makes the appropriate change.",
            "examples": [
                {
                    "code": "class Todos extends Component{ public $todo = '';  public $todos = [ 'first', 'second', ];  public function add() { $this->todos[] = $this->todo; }}",
                    "type": "class"
                },
                {
                    "code": "<form wire:submit=\"add\"> <ul> @foreach ($todos as $item) <li>{{ $item }}</li> @endforeach </ul>  <input wire:model=\"todo\"></form>",
                    "type": "class"
                },
                {
                    "code": "<form wire:submit=\"add\"> <ul> <li>first</li>  <li>second</li> </ul>  <input wire:model=\"todo\"></form>",
                    "type": "class"
                },
                {
                    "code": "<form wire:submit=\"add\"> <ul> <li>first</li>   <li>second</li>  + <li>third</li> </ul>   <input wire:model=\"todo\"> </form>",
                    "type": "class"
                }
            ]
        },
        {
            "title": "#Morphing shortcomings",
            "content": "The following are scenarios where morphing algorithms fail to correctly identify the change in HTML trees and therefore cause problems in your application.\nConsider the following Livewire Blade template for a fictitious CreatePost component:\nIf a user tries submitting the form, but encounters a validation error, the following problem occurs:\nAs you can see, when Livewire encounters the new <div> for the error message, it doesn't know whether to change the existing <div> in-place, or insert the new <div> in the middle.\nTo re-iterate what's happening more explicitly:\nThis scenario is at the root of almost all morph-related bugs.\nHere are a few specific problematic impacts of these bugs:\nFortunately, Livewire has worked hard to mitigate these problems using the following approaches:\nLivewire has an additional step in its morphing algorithm that checks subsequent elements and their contents before changing an element.\nThis prevents the above scenario from happening in many cases.\nHere is a visualization of the \"look-ahead\" algorithm in action:\nOn the backend, Livewire automatically detects conditionals inside Blade templates and wraps them in HTML comment markers that Livewire's JavaScript can use as a guide when morphing.\nHere's an example of the previous Blade template but with Livewire's injected markers:\nWith these markers injected into the template, Livewire can now more easily detect the difference between a change and an addition.\nThis feature is extremely beneficial to Livewire applications, but because it requires parsing templates via regex, it can sometimes fail to properly detect conditionals. If this feature is more of a hindrance than a help to your application, you can disable it with the following configuration in your application's config/livewire.php file:\nIf the above two solutions don't cover your situation, the most reliable way to avoid morphing problems is to wrap conditionals and loops in their own elements that are always present.\nFor example, here's the above Blade template rewritten with wrapping <div> elements:\nNow that the conditional has been wrapped in a persistent element, Livewire will morph the two different HTML trees properly.\nIf you need to bypass morphing entirely for an element, you can use wire:replace to instruct livewire to replace all children of an element instead of attempting to morph the existing elements.",
            "examples": [
                {
                    "code": "<form wire:submit=\"save\"> <div> <input wire:model=\"title\"> </div>  @if ($errors->has('title')) <div>{{ $errors->first('title') }}</div> @endif  <div> <button>Save</button> </div></form>",
                    "type": "class"
                },
                {
                    "code": "<form wire:submit=\"save\"> <div> <input wire:model=\"title\"> </div>  <!--[if BLOCK]><![endif]--> @if ($errors->has('title')) <div>Error: {{ $errors->first('title') }}</div> @endif <!--[if ENDBLOCK]><![endif]-->  <div> <button>Save</button> </div></form>",
                    "type": "class"
                },
                {
                    "code": "'inject_morph_markers' => false,",
                    "type": "class"
                },
                {
                    "code": "<form wire:submit=\"save\"> <div> <input wire:model=\"title\"> </div>  <div> @if ($errors->has('title')) <div>{{ $errors->first('title') }}</div> @endif </div>   <div> <button>Save</button> </div></form>",
                    "type": "class"
                }
            ]
        }
    ],
    "directives_used": [
        "wire:model",
        "wire:submit"
    ],
    "related": [
        "quickstart",
        "installation",
        "upgrading",
        "components",
        "properties",
        "actions",
        "forms",
        "events",
        "lifecycle-hooks",
        "nesting"
    ],
    "scraped_at": "2026-01-02T23:37:55+00:00"
}
