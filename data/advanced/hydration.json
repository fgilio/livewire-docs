{
    "slug": "hydration",
    "title": "Hydration",
    "description": "Using Livewire feels like attaching a server-side PHP class directly to a web browser. Things like calling server-side functions directly from button presses support this illusion. But in reality, it is just that: an illusion.",
    "category": "advanced",
    "url": "https://livewire.laravel.com/docs/3.x/hydration",
    "sections": [
        {
            "title": "#Dehydrating",
            "content": "When Livewire dehydrates a server-side component, it does two things:\nAfter a component is mounted or an update has been made, Livewire calls a component's render() method to convert the Blade template to raw HTML.\nTake the following Counter component for example:\nAfter each mount or update, Livewire would render the above Counter component to the following HTML:\nIn order to re-create the Counter component on the server during the next request, a JSON snapshot is created, attempting to capture as much of the state of the component as possible:\nNotice two different portions of the snapshot: memo, and state.\nThe memo portion is used to store the information needed to identify and re-create the component, while the state portion stores the values of all the component's public properties.\nThe above snapshot is a condensed version of an actual snapshot in Livewire. In live applications, the snapshot contains much more information, such as validation errors, a list of child components, locales, and much more. For a more detailed look at a snapshot object you may reference the snapshot schema documentation.\nWhen a component is first rendered, Livewire stores the snapshot as JSON inside an HTML attribute called wire:snapshot. This way, Livewire's JavaScript core can extract the JSON and turn it into a run-time object:",
            "examples": [
                {
                    "code": "class Counter extends Component{ public $count = 1;  public function increment() { $this->count++; }  public function render() { return <<<'HTML' <div> Count: {{ $count }}  <button wire:click=\"increment\">+</button> </div> HTML; }}",
                    "type": "class"
                },
                {
                    "code": "<div> Count: 1  <button wire:click=\"increment\">+</button></div>",
                    "type": "class"
                },
                {
                    "code": "{ state: { count: 1, },  memo: { name: 'counter',  id: '1526456', },}",
                    "type": "class"
                },
                {
                    "code": "<div wire:id=\"...\" wire:snapshot=\"{ state: {...}, memo: {...} }\"> Count: 1  <button wire:click=\"increment\">+</button></div>",
                    "type": "class"
                }
            ]
        },
        {
            "title": "#Hydrating",
            "content": "When a component update is triggered, for example, the \"+\" button is pressed in the Counter component, a payload like the following is sent to the server:\nBefore Livewire can call the increment method, it must first create a new Counter instance and seed it with the snapshot's state.\nHere is some PHP pseudo-code that achieves this result:\nIf you follow the above script, you will see that after creating a Counter object, its public properties are set based on the state provided from the snapshot.",
            "examples": [
                {
                    "code": "{ calls: [ { method: 'increment', params: [] }, ],  snapshot: { state: { count: 1, },  memo: { name: 'counter',  id: '1526456', }, }}",
                    "type": "class"
                },
                {
                    "code": "$state = request('snapshot.state');$memo = request('snapshot.memo'); $instance = Livewire::new($memo['name'], $memo['id']); foreach ($state as $property => $value) { $instance[$property] = $value;}",
                    "type": "class"
                }
            ]
        },
        {
            "title": "#Advanced hydration",
            "content": "The above Counter example works well to demonstrate the concept of hydration; however, it only demonstrates how Livewire handles hydrating simple values like integers (1).\nAs you may know, Livewire supports many more sophisticated property types beyond integers.\nLet's take a look at a slightly more complex example - a Todos component:\nAs you can see, we are setting the $todos property to a Laravel collection with three strings as its content.\nJSON alone has no way of representing Laravel collections, so instead, Livewire has created its own pattern of associating metadata with pure data inside a snapshot.\nHere is the snapshot's state object for this Todos component:\nThis may be confusing to you if you were expecting something more straightforward like:\nHowever, if Livewire were hydrating a component based on this data, it would have no way of knowing it's a collection and not a plain array.\nTherefore, Livewire supports an alternate state syntax in the form of a tuple (an array of two items):\nWhen Livewire encounters a tuple when hydrating a component's state, it uses information stored in the second element of the tuple to more intelligently hydrate the state stored in the first.\nTo demonstrate more clearly, here is simplified code showing how Livewire might re-create a collection property based on the above snapshot:\nAs you can see, Livewire uses the metadata associated with the state to derive the full collection class.\nOne distinct advantage of this approach is the ability to dehydrate and hydrate deeply nested properties.\nFor example, consider the above Todos example, except now with a Laravel Stringable instead of a plain string as the third item in the collection:\nThe dehydrated snapshot for this component's state would now look like this:\nAs you can see, the third item in the collection has been dehydrated into a metadata tuple. The first element in the tuple being the plain string value, and the second being a flag denoting to Livewire that this string is a stringable.\nInternally, Livewire has hydration support for the most common PHP and Laravel types. However, if you wish to support un-supported types, you can do so using Synthesizers — Livewire's internal mechanism for hydrating/dehydrating non-primitive property types.",
            "examples": [
                {
                    "code": "class Todos extends Component{ public $todos;  public function mount() { $this->todos = collect([ 'first', 'second', 'third', ]); }}",
                    "type": "class"
                },
                {
                    "code": "state: { todos: [ [ 'first', 'second', 'third' ], { s: 'clctn', class: 'Illuminate\\\\Support\\\\Collection' }, ],},",
                    "type": "class"
                },
                {
                    "code": "state: { todos: [ 'first', 'second', 'third' ],},",
                    "type": "class"
                },
                {
                    "code": "todos: [ [ 'first', 'second', 'third' ], { s: 'clctn', class: 'Illuminate\\\\Support\\\\Collection' },],",
                    "type": "class"
                },
                {
                    "code": "[ $state, $metadata ] = request('snapshot.state.todos'); $collection = new $metadata['class']($state);",
                    "type": "class"
                },
                {
                    "code": "class Todos extends Component{ public $todos;  public function mount() { $this->todos = collect([ 'first', 'second', str('third'), ]); }}",
                    "type": "class"
                },
                {
                    "code": "todos: [ [ 'first', 'second', [ 'third', { s: 'str' } ], ], { s: 'clctn', class: 'Illuminate\\\\Support\\\\Collection' },],",
                    "type": "class"
                }
            ]
        }
    ],
    "directives_used": [
        "wire:click",
        "wire:id",
        "wire:snapshot"
    ],
    "related": [
        "quickstart",
        "installation",
        "upgrading",
        "components",
        "properties",
        "actions",
        "forms",
        "events",
        "lifecycle-hooks",
        "nesting"
    ],
    "scraped_at": "2026-01-02T23:37:57+00:00"
}
